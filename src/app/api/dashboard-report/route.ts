import { prisma } from "@/src/lib/db";
import { NextResponse } from "next/server";
import PDFDocument from "pdfkit";
import path from "path";
import fetch from "node-fetch";

export async function GET(req: Request) {
  const url = new URL(req.url);
  const days = parseInt(url.searchParams.get("days") || "7"); // default 7 days
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);
  startDate.setHours(0, 0, 0, 0);

  // Aggregate data
  const totalRevenueAgg = await prisma.order.aggregate({
    _sum: { totalAmount: true },
    where: { createdAt: { gte: startDate } },
  });
  const totalRevenue = totalRevenueAgg._sum.totalAmount || 0;

  const ordersCount = await prisma.order.count({
    where: { createdAt: { gte: startDate } },
  });
  const customersCount = await prisma.user.count({
    where: { createdAt: { gte: startDate } },
  });
  const productsCount = await prisma.product.count();

  const topProductsStats = await prisma.orderItem.groupBy({
    by: ["productId"],
    _sum: { quantity: true },
    where: { order: { createdAt: { gte: startDate } } },
    orderBy: { _sum: { quantity: "desc" } },
    take: 20,
  });

  const topProducts = await Promise.all(
    topProductsStats.map(async (item) => {
      const product = await prisma.product.findUnique({
        where: { id: item.productId },
      });
      const revenue = (item._sum.quantity || 0) * (product?.price || 0);
      return {
        name: product?.name || "-",
        sales: item._sum.quantity || 0,
        revenue: revenue.toFixed(2),
      };
    })
  );

  // Revenue & Orders per day
  const revenueTrend: number[] = [];
  const ordersPerDay: number[] = [];
  const labels: string[] = [];

  for (let i = 0; i < days; i++) {
    const day = new Date(startDate);
    day.setDate(startDate.getDate() + i);
    const nextDay = new Date(day);
    nextDay.setDate(day.getDate() + 1);

    const dayOrders = await prisma.order.findMany({
      where: { createdAt: { gte: day, lt: nextDay } },
    });

    const dayRevenue = dayOrders.reduce((sum, o) => sum + o.totalAmount, 0);
    revenueTrend.push(dayRevenue);
    ordersPerDay.push(dayOrders.length);
    labels.push(day.toLocaleDateString());
  }

  // Fonts
  const regularFont = path.join(
    process.cwd(),
    "public/fonts/Poppins-Regular.ttf"
  );
  const boldFont = path.join(process.cwd(), "public/fonts/Poppins-Bold.ttf");

  const pdfBuffer: Buffer = await new Promise(async (resolve) => {
    const doc = new PDFDocument({
      size: "A4",
      margin: 50,
      font: regularFont,
    });

    const chunks: Buffer[] = [];

    doc.registerFont("Poppins", regularFont);
    doc.registerFont("Poppins-Bold", boldFont);
    doc.font("Poppins");

    doc.on("data", (chunk: any) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    // Footer helper
    const addFooter = () => {
      const footerY = doc.page.height - doc.page.margins.bottom - 40;
      doc
        .moveTo(50, footerY)
        .lineTo(550, footerY)
        .strokeColor("#D1D5DB")
        .stroke();
      doc
        .font("Poppins")
        .fontSize(10)
        .fillColor("#6B7280")
        .text("Generated by Miskblooming Admin Dashboard", 50, footerY + 15, {
          align: "center",
          width: 500,
        });
    };
    doc.on("pageAdded", addFooter);

    // Header
    doc
      .font("Poppins-Bold")
      .fontSize(22)
      .fillColor("#1F2937")
      .text("Miskblooming Dashboard Report", 50, 50);
    doc
      .font("Poppins")
      .fontSize(10)
      .fillColor("#4B5563")
      .text(`Period: Last ${days} days`, 50, 80)
      .text(`Generated on: ${new Date().toLocaleDateString()}`, 50, 95);

    doc.moveDown(2);

    // Summary KPIs
    let y = doc.y;
    const addKPI = (label: string, value: string) => {
      doc.font("Poppins-Bold").fontSize(12).text(label, 50, y);
      doc.font("Poppins").text(value, 180, y);
      y += 20;
    };
    addKPI("Total Revenue:", `$${totalRevenue.toFixed(2)}`);
    addKPI("Total Orders:", ordersCount.toString());
    addKPI("Total Products:", productsCount.toString());
    addKPI("Total Customers:", customersCount.toString());

    y += 20;

    // Revenue Chart
    const revenueChartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(
      JSON.stringify({
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Revenue",
              data: revenueTrend,
              borderColor: "blue",
              fill: false,
            },
          ],
        },
      })
    )}`;
    const revenueRes = await fetch(revenueChartUrl);
    const revenueBuffer = Buffer.from(await revenueRes.arrayBuffer());
    doc.image(revenueBuffer, 50, y, { width: 500, height: 200 });
    y += 220;

    // Orders Chart
    const ordersChartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(
      JSON.stringify({
        type: "bar",
        data: {
          labels,
          datasets: [
            { label: "Orders", data: ordersPerDay, backgroundColor: "green" },
          ],
        },
      })
    )}`;
    const ordersRes = await fetch(ordersChartUrl);
    const ordersBuffer = Buffer.from(await ordersRes.arrayBuffer());
    doc.image(ordersBuffer, 50, y, { width: 500, height: 200 });
    y += 220;

    // Top Products Table
    doc.addPage();
    y = 50;
    doc.font("Poppins-Bold").text("Top Selling Products:", 50, y);
    y += 20;
    doc.font("Poppins-Bold").text("Product Name", 50, y);
    doc.text("Sales", 300, y);
    doc.text("Revenue", 400, y);
    y += 20;

    for (const item of topProducts) {
      if (y > doc.page.height - 100) doc.addPage() && (y = 50);
      doc.font("Poppins").text(item.name, 50, y);
      doc.text(item.sales.toString(), 300, y);
      doc.text(`$${item.revenue}`, 400, y);
      y += 20;
    }

    addFooter();
    doc.end();
  });

  return new NextResponse(new Uint8Array(pdfBuffer), {
    headers: {
      "Content-Type": "application/pdf",
      "Content-Disposition": `attachment; filename=dashboard-report-${days}-days.pdf`,
    },
  });
}
