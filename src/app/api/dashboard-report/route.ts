import { prisma } from "@/src/lib/db";
import { NextResponse } from "next/server";
import PDFDocument from "pdfkit";
import path from "path";
import fetch from "node-fetch";

export async function GET(req: Request) {
  const url = new URL(req.url);
  const days = parseInt(url.searchParams.get("days") || "7"); // Default last 7 days
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);

  // Aggregate data
  const totalRevenue = await prisma.order.aggregate({
    _sum: { totalAmount: true },
    where: { createdAt: { gte: startDate } },
  });

  const ordersCount = await prisma.order.count({
    where: { createdAt: { gte: startDate } },
  });

  const customersCount = await prisma.user.count({
    where: { createdAt: { gte: startDate } },
  });

  const productsCount = await prisma.product.count();

  const topProducts = await prisma.orderItem.groupBy({
    by: ["productId"],
    _sum: { quantity: true, price: true },
    where: {
      order: {
        createdAt: { gte: startDate },
      },
    },
    orderBy: { _sum: { quantity: "desc" } },
    take: 20,
  });

  // Revenue Trend & Orders per Day
  const revenueTrend: number[] = [];
  const ordersPerDay: number[] = [];
  const labels: string[] = [];

  for (let i = 0; i < days; i++) {
    const day = new Date();
    day.setDate(day.getDate() - (days - 1 - i));
    const nextDay = new Date(day);
    nextDay.setDate(day.getDate() + 1);

    const dayOrders = await prisma.order.findMany({
      where: { createdAt: { gte: day, lt: nextDay } },
    });

    const dayRevenue = dayOrders.reduce((sum, o) => sum + o.totalAmount, 0);
    revenueTrend.push(dayRevenue);
    ordersPerDay.push(dayOrders.length);
    labels.push(day.toLocaleDateString());
  }

  // Fonts
  const regularFont = path.join(
    process.cwd(),
    "public/fonts/Poppins-Regular.ttf"
  );
  const boldFont = path.join(process.cwd(), "public/fonts/Poppins-Bold.ttf");

  const pdfBuffer: Buffer = await new Promise(async (resolve) => {
    const doc = new PDFDocument({ size: "A4", margin: 50, font: regularFont });
    const chunks: Buffer[] = [];

    doc.registerFont("Poppins", regularFont);
    doc.registerFont("Poppins-Bold", boldFont);
    doc.font("Poppins");

    doc.on("data", (chunk: any) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));

    // -------- Helper: Footer --------
    const addFooter = () => {
      const footerHeight = 50;
      const footerY = doc.page.height - doc.page.margins.bottom - footerHeight;
      doc
        .moveTo(50, footerY)
        .lineTo(550, footerY)
        .strokeColor("#D1D5DB")
        .stroke();
      doc
        .font("Poppins")
        .fontSize(10)
        .fillColor("#6B7280")
        .text("Generated by Miskblooming Admin Dashboard", 50, footerY + 15, {
          align: "center",
          width: 500,
        });
    };

    doc.on("pageAdded", addFooter);

    // -------- Header --------
    const headerTop = 50;
    doc
      .font("Poppins-Bold")
      .fontSize(22)
      .fillColor("#1F2937")
      .text("Miskblooming Dashboard Report", 50, headerTop);
    doc
      .font("Poppins")
      .fontSize(10)
      .fillColor("#4B5563")
      .text(`Period: Last ${days} days`, 50, headerTop + 30)
      .text(
        `Generated on: ${new Date().toLocaleDateString()}`,
        50,
        headerTop + 45
      );

    doc.moveDown(2);

    // -------- Summary KPIs --------
    let y = doc.y;
    const addKPI = (label: string, value: string) => {
      doc.font("Poppins-Bold").fontSize(12).text(label, 50, y);
      doc.font("Poppins").text(value, 180, y);
      y += 20;
    };

    addKPI(
      "Total Revenue:",
      `$${totalRevenue._sum.totalAmount?.toFixed(2) || 0}`
    );
    addKPI("Total Orders:", ordersCount.toString());
    addKPI("Total Products:", productsCount.toString());
    addKPI("Total Customers:", customersCount.toString());

    y += 20;

    // -------- Revenue Trend Chart --------
    const revenueChartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(
      JSON.stringify({
        type: "line",
        data: {
          labels,
          datasets: [
            {
              label: "Revenue",
              data: revenueTrend,
              borderColor: "blue",
              fill: false,
            },
          ],
        },
      })
    )}`;
    const revenueRes = await fetch(revenueChartUrl);
    const revenueBuffer = Buffer.from(await revenueRes.arrayBuffer());
    doc.image(revenueBuffer, 50, y, { width: 500, height: 200 });
    y += 220;

    // -------- Orders Per Day Chart --------
    const ordersChartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(
      JSON.stringify({
        type: "bar",
        data: {
          labels,
          datasets: [
            { label: "Orders", data: ordersPerDay, backgroundColor: "green" },
          ],
        },
      })
    )}`;
    const ordersRes = await fetch(ordersChartUrl);
    const ordersBuffer = Buffer.from(await ordersRes.arrayBuffer());
    doc.image(ordersBuffer, 50, y, { width: 500, height: 200 });
    y += 220;

    // -------- Top Products Table --------
    doc.addPage();
    y = 50;
    doc.font("Poppins-Bold").text("Top Selling Products:", 50, y);
    y += 20;

    doc.font("Poppins-Bold").text("Product Name", 50, y);
    doc.text("Sales", 300, y);
    doc.text("Revenue", 400, y);
    y += 20;

    for (const item of topProducts) {
      const product = await prisma.product.findUnique({
        where: { id: item.productId },
      });
      if (y > doc.page.height - 100) doc.addPage() && (y = 50);
      doc.font("Poppins").text(product?.name || "-", 50, y);
      doc.text(item._sum.quantity?.toString() || "0", 300, y);
      doc.text(item._sum.price?.toFixed(2) || "0.00", 400, y);
      y += 20;
    }

    // -------- Footer on last page --------
    addFooter();

    doc.end();
  });

  return new NextResponse(new Uint8Array(pdfBuffer), {
    headers: {
      "Content-Type": "application/pdf",
      "Content-Disposition": `attachment; filename=dashboard-report-${days}-days.pdf`,
    },
  });
}
